演示功能的使用,单个文件和多个文件上传,中断上传之后继续上传,多个不同的状态

需求:
上传多个几百m或者1G多的文件给服务器
可以中途取消和暂停上传
页面关闭中断了上传,手动暂停上传,因网络问题自动中断了上传.那下次再打开可以自动继续之前的上传

前端 -
思路:
使用input标签选择文件
使用md5计算文件的哈希值作为文件的身份证(唯一标识),用以后边判断有没上传过或者继续上传剩下的分片
发送哈希值给后端,如果返回-1就秒上传过.如果返回1就服务器没有可以上传
使用File.slice以3m为一个单位分割,逐片发送给后端,如果连续上传失败三次就自动中断上传
上传所有分片的同时可以看到进度条上传了百分之多少
上传成功的分片个数等于总分片数,请求后端合并所有分片接口,最后返回1,整个文件都上传完成
遇到的问题和解决方案:
1.axios监听上传进度的函数onUploadProgress只触发了一次而已:
要满足两个条件,缺一不可 - ①只能传FormData对象 ②要有File数据类型在请求参数里
2.onUploadProgress,在请求超时或者服务器异常的时候它一样会触发
因为这个api返回的进度只是文件上传到服务器的进度而已,可是上传到服务器了就绝对完成了,后端也会报错造成上传失败. 上传完成 !== 上传成功
我们这个功能本来就是分片的,如果分了100片相当于一片占了100里的一份,这就是进度.响应返回上传分片成功,更新一次进度, 进度 = 进度 + 总片数/100
如果你没做分片,是直接一整个比较大的文件一次上传给服务器的,这种情况可以用这个api,最终上传接口返回上传成功或者失败. 上百个分片就算了,容易产生误会
3.用md5计算大的文件很慢:
直接计算整个文件 => 使用web worker创建多一个子线程计算,计算完返回给主线程 => 子线程里,追加分片计算哈希 => 子线程里,只追加计算第一片和最后一片
4.浏览器同域名同一时间请求的最大并发数限制为6
一开始是打算一次循环请求几百个接口或者使用Promise.all(),这样就几乎同时发送几百个接口了,这样效率高一些,后来发现文件小没事,大了请求直接不响应了
所以要将请求错开，一个请求响应完成了再执行下一个。不要并发很多个请求。
5.浏览器客户端的安全设置是不允许自动访问本地资源和获取本地路径的,除非像input标签那样用户点主动击上传,要用户参与:
这种情况就只能改变功能
之前我是打算和迅雷那样一打开页面就看到所有可以继续上传的任务,想继续上传哪个就点哪个.可是因为这个原因,就改成了,每次重新进来这个页面都是空的,如果之前有上传了一部分了,只要上传了一样的文件就会自动续传
6.indexDB存的数据量大,它存储到缓存这个api的执行速度比较慢.例如想监听页面卸载前生命周期执行一次设置缓存,你会发现.数据量一大就设置失败,显示的还是之前的数据
优化数据,不要放File数据类型
改变逻辑,不使用监听页面卸载前的生命周期,在监听事件里实时存储缓存
因为是要实时存储到缓存的,所以执行setitem这个api前不要做一些复杂的逻辑,要做复杂的逻辑,下次获取的时候再处理

后端 -
思路:
查看文件接口-
先根据前端传过来的文件大小判断本地够不够空间,不够直接返回-2
根据前端传过来的哈希值查看缓存文件夹里有没与之一致的文件夹名称,没有就返回1,有就返回-1
请求接口-
接收前端发送过来的上传分片请求,以哈希值为文件夹名称,以文件名后缀和分片的文件名称添加到指定的文件夹里
文件创建完成就返回前端分片上传完成,其中一个环节报了异常就返回上传失败给前端
合并所有分片接口-
接收前端传过来的哈希值,根据这个哈希值找到缓存文件夹里与之对应的文件夹名称
根据所有分片名称上包含的下标,有序的追加到可写流,最后关闭可写流,删除放所有分片的文件夹
清空服务器里存储的所有文件-
获取缓存文件夹和完成文件夹里的所有文件,删除里边所有文件和文件夹,不包括.gitignore文件
遇到的问题和解决方案:
1.node进程异常导致以后都无法再次访问服务器:
try...catch... 每一个接口返回执行的逻辑有异常隐患的都用try...catch...做好逻辑处理
回调函数的error,也做好逻辑处理
process.on('uncaughtException')监听剩下没有捕捉到的进程异常,完全杜绝node服务器崩溃
2.writeFileSync内部有延迟发生,官方文档写着它是同步执行的,偶尔会出现已经执行它的下一行代码了,文件却还没创建完成
只能使用fs.write('',(err,data)=>{})这种写法, 这样就完全不会出现代码执行完了可是获取文件获取不到
3.服务器的两个专门用来存储数据的空文件夹无法推到git
git是无法识别空文件夹的,除非手动在这个文件夹里添加一个.gitignore文件
4.拼接路径的时候总是报路径错误
因为路径有两种写法,手写的路径是左斜杠,node的api获取到的路径是是右斜杠
最保险的,不要用模板字符串拼接路径,都用path.join()
5.os.freemem()获取到的值与文件所在的磁盘剩余空间不一致
目前理解的是
os.freemem()获取到的其实是空闲内存量,和本地磁盘的剩余空间不是一个东西,服务器显示的都是几G内存,所以os.freemem()这个api主要是计算服务器空闲内存的,不一致也是正常的,本地开发的时候用这个os.freemem()做逻辑判断就可以了